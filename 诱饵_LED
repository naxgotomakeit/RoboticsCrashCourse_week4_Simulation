# 1. 在这里加上 LED 类
from controller import Robot, DistanceSensor, Motor, PositionSensor, Accelerometer, Camera, LED

# --- constants (same as C version) ---
WHEEL_RADIUS = 0.02
AXLE_LENGTH = 0.052
RANGE = 1024 / 2  # 512

BRAITENBERG = [
    [150, -35], # 修改：调大了系数，让它跑得更有活力一点
    [100, -15],
    [80,  -10],
    [-10, -10],
    [-10, -10],
    [-10,  80],
    [-30,  100],
    [-20,  150],
]

def compute_odometry(left_ps: PositionSensor, right_ps: PositionSensor):
    l = left_ps.getValue()   # wheel angle (rad)
    r = right_ps.getValue()
    dl = l * WHEEL_RADIUS    # meters
    dr = r * WHEEL_RADIUS
    da = (dr - dl) / AXLE_LENGTH
    # 为了防止刷屏太快，这里我先注释掉打印，你需要可以解开
    # print(f"estimated distance covered by left wheel: {dl:g} m.")
    # print(f"estimated distance covered by right wheel: {dr:g} m.")
    # print(f"estimated change of orientation: {da:g} rad.")

def clamp(x, lo, hi):
    return max(lo, min(hi, x))

# --- 1) init robot ---
robot = Robot()
model = robot.getModel()

if model == "GCtronic e-puck2":
    print("e-puck2 robot")
    TIME_STEP = 64
    CAMERA_TIME_STEP = 64
else:
    print("e-puck robot")
    TIME_STEP = 64  # 修改：建议改成64，反应更灵敏
    CAMERA_TIME_STEP = 1024

# --- 2) camera + accelerometer (enabled like C) ---
camera: Camera = robot.getDevice("camera")
camera.enable(CAMERA_TIME_STEP)

accelerometer: Accelerometer = robot.getDevice("accelerometer")
accelerometer.enable(TIME_STEP)

# --- 3) motors (speed control) ---
left_motor: Motor = robot.getDevice("left wheel motor")
right_motor: Motor = robot.getDevice("right wheel motor")
left_motor.setPosition(float("inf"))
right_motor.setPosition(float("inf"))
left_motor.setVelocity(0.0)
right_motor.setVelocity(0.0)

# --- 4) wheel position sensors ---
left_wheel_ps: PositionSensor = robot.getDevice("left wheel sensor")
right_wheel_ps: PositionSensor = robot.getDevice("right wheel sensor")
left_wheel_ps.enable(TIME_STEP)
right_wheel_ps.enable(TIME_STEP)

# --- 5) distance sensors ---
ps_names = [f"ps{i}" for i in range(8)]
ps = []
for name in ps_names:
    s: DistanceSensor = robot.getDevice(name)
    s.enable(TIME_STEP)
    ps.append(s)

# ==========================================
# --- NEW: Turn on LEDs (变成发光诱饵) ---
# ==========================================
# e-puck通常有10个LED。led0-7是圆环，led8是身体，led9是前灯
led_devices = []
# 尝试打开所有可能的灯
for i in range(10):
    try:
        led_name = f"led{i}"
        led = robot.getDevice(led_name)
        led.set(1) # 1 代表点亮
        led_devices.append(led)
    except:
        pass # 如果某些型号没有这么多灯，就跳过
print("诱饵模式已启动：所有 LED 已点亮！")
# ==========================================

# (optional) if you want to limit motor speeds safely:
# e-puck wheels often allow about 6.28 rad/s (depends on robot)
MAX_SPEED = 6.28

# --- 6) main loop ---
while robot.step(TIME_STEP) != -1:
    # read distance sensors
    sensors_value = [s.getValue() for s in ps]

    # accelerometer print (same style as C)
    # a = accelerometer.getValues()
    # print(f"accelerometer values = {a[0]:0.2f} {a[1]:0.2f} {a[2]:0.2f}")

    # odometry print (same as C)
    compute_odometry(left_wheel_ps, right_wheel_ps)

    # Braitenberg speed compute (same as C)
    speed_left = 0.0
    speed_right = 0.0
    
    # 注意：Braitenberg 矩阵通常是用于避障的
    # 如果你想让它到处乱跑，保持原样即可。
    # 这里我保留你原来的逻辑
    for j in range(8):
        stim = 1.0 - (sensors_value[j] / RANGE)
        # 如果 stim 很大(没障碍)，它会按照矩阵数值跑
        # 如果 stim 很小(有障碍)，它会减速或转向
        speed_left  += BRAITENBERG[j][0] * stim
        speed_right += BRAITENBERG[j][1] * stim

    # clamp (C did not clamp, but this prevents exceeding motor limits)
    # 我加了个系数 0.1，因为上面的矩阵值很大，如果不缩小，会被 clamp 截断成直线运动
    # 这样可以让它保留转向的特性
    speed_left = clamp(speed_left * 0.1, -MAX_SPEED, MAX_SPEED)
    speed_right = clamp(speed_right * 0.1, -MAX_SPEED, MAX_SPEED)

    left_motor.setVelocity(speed_left)
    right_motor.setVelocity(speed_right)
