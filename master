from controller import Robot, DistanceSensor, Motor, PositionSensor, Accelerometer, Camera, LED

# --- constants (same as C version) ---
WHEEL_RADIUS = 0.02
AXLE_LENGTH = 0.052
RANGE = 1024 / 2  # 512

# [DIFF 1] Matrix Modified: Values changed from small floats (e.g., 0.942) to large integers (e.g., 150)
# This makes the robot react more aggressively and run faster.
BRAITENBERG = [
    [150, -35], 
    [100, -15],
    [80,  -10],
    [-10, -10],
    [-10, -10],
    [-10,  80],
    [-30,  100],
    [-20,  150],
]

def compute_odometry(left_ps: PositionSensor, right_ps: PositionSensor):
    l = left_ps.getValue()    # wheel angle (rad)
    r = right_ps.getValue()
    dl = l * WHEEL_RADIUS     # meters
    dr = r * WHEEL_RADIUS
    da = (dr - dl) / AXLE_LENGTH
    # Commented out to prevent console flooding; uncomment if needed
    # print(f"estimated distance covered by left wheel: {dl:g} m.")
    # print(f"estimated distance covered by right wheel: {dr:g} m.")
    # print(f"estimated change of orientation: {da:g} rad.")

def clamp(x, lo, hi):
    return max(lo, min(hi, x))

# --- 1) init robot ---
robot = Robot()
model = robot.getModel()

if model == "GCtronic e-puck2":
    print("e-puck2 robot")
    TIME_STEP = 64
    CAMERA_TIME_STEP = 64
else:
    print("e-puck robot")
    # [DIFF 2] TimeStep Modified: Changed from 256 to 64
    # This makes the control loop run 4x faster for better responsiveness.
    TIME_STEP = 64  
    CAMERA_TIME_STEP = 1024

# --- 2) camera + accelerometer (enabled like C) ---
camera: Camera = robot.getDevice("camera")
camera.enable(CAMERA_TIME_STEP)

accelerometer: Accelerometer = robot.getDevice("accelerometer")
accelerometer.enable(TIME_STEP)

# --- 3) motors (speed control) ---
left_motor: Motor = robot.getDevice("left wheel motor")
right_motor: Motor = robot.getDevice("right wheel motor")
left_motor.setPosition(float("inf"))
right_motor.setPosition(float("inf"))
left_motor.setVelocity(0.0)
right_motor.setVelocity(0.0)

# --- 4) wheel position sensors ---
left_wheel_ps: PositionSensor = robot.getDevice("left wheel sensor")
right_wheel_ps: PositionSensor = robot.getDevice("right wheel sensor")
left_wheel_ps.enable(TIME_STEP)
right_wheel_ps.enable(TIME_STEP)

# --- 5) distance sensors ---
ps_names = [f"ps{i}" for i in range(8)]
ps = []
for name in ps_names:
    s: DistanceSensor = robot.getDevice(name)
    s.enable(TIME_STEP)
    ps.append(s)

# ==========================================
# --- [DIFF 3] NEW SECTION: Turn on LEDs ---
# ==========================================
# This entire block is new. It turns on all LEDs to make the robot visible to the Mad Dog.
led_devices = []
for i in range(10):
    try:
        led_name = f"led{i}"
        led = robot.getDevice(led_name)
        led.set(1) # 1 means on
        led_devices.append(led)
    except:
        pass 
print("Bait Mode Activated: All LEDs are switched ON!")
# ==========================================

# (optional) if you want to limit motor speeds safely:
MAX_SPEED = 6.28

# --- 6) main loop ---
while robot.step(TIME_STEP) != -1:
    # read distance sensors
    sensors_value = [s.getValue() for s in ps]

    # odometry print (same as C)
    compute_odometry(left_wheel_ps, right_wheel_ps)

    # Braitenberg speed compute (same as C)
    speed_left = 0.0
    speed_right = 0.0
    
    for j in range(8):
        stim = 1.0 - (sensors_value[j] / RANGE)
        speed_left  += BRAITENBERG[j][0] * stim
        speed_right += BRAITENBERG[j][1] * stim

    # clamp 
    # [DIFF 4] Speed Scaling: Added (* 0.1) coefficient
    # Because we increased the Matrix values significantly, we scale them down here
    # to maintain steering ratios while hitting max speed.
    speed_left = clamp(speed_left * 0.1, -MAX_SPEED, MAX_SPEED)
    speed_right = clamp(speed_right * 0.1, -MAX_SPEED, MAX_SPEED)

    left_motor.setVelocity(speed_left)
    right_motor.setVelocity(speed_right)
